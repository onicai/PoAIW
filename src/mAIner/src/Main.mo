import Array "mo:base/Array";
import Buffer "mo:base/Buffer";
import D "mo:base/Debug";
import Error "mo:base/Error";
import Principal "mo:base/Principal";
import Text "mo:base/Text";
import Nat "mo:base/Nat";
import Nat64 "mo:base/Nat64";
import Bool "mo:base/Bool";
import HashMap "mo:base/HashMap";
import List "mo:base/List";
import Int "mo:base/Int";
import Time "mo:base/Time";

import Types "Types";
import Utils "Utils";

actor class MainerAgentCtrlbCanister() = this {

    stable var GAME_STATE_CANISTER_ID : Text = "bkyz2-fmaaa-aaaaa-qaaaq-cai"; // local dev: "bkyz2-fmaaa-aaaaa-qaaaq-cai";

    stable let gameStateCanisterActor = actor(GAME_STATE_CANISTER_ID): Types.GameStateCanister_Actor;
    
    public shared (msg) func setGameStateCanisterId(_game_state_canister_id : Text) : async Types.AuthRecordResult {
        if (not Principal.isController(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        GAME_STATE_CANISTER_ID := _game_state_canister_id;
        let authRecord = { auth = "You set the id for this canister." };
        return #Ok(authRecord);
    };

    // Orthogonal Persisted Data storage

    // Record of settings
    stable var agentSettings : List.List<Types.MainerAgentSettings> = List.nil<Types.MainerAgentSettings>();
    
    private func putAgentSettings(settingsEntry : Types.MainerAgentSettings) : Bool {
        let putResult = List.push<Types.MainerAgentSettings>(settingsEntry, agentSettings);
        return true;
    };

    private func getCurrentAgentSettings() : ?Types.MainerAgentSettings {
        return List.get<Types.MainerAgentSettings>(agentSettings, 0);
    };

    // Record of generated responses
    stable var generatedResponses : List.List<Types.ChallengeResponse> = List.nil<Types.ChallengeResponse>();
    
    private func putGeneratedResponse(responseEntry : Types.ChallengeResponse) : Bool {
        let putResult = List.push<Types.ChallengeResponse>(responseEntry, generatedResponses);
        return true;
    };

    private func getGeneratedResponse(challengeId : Text) : ?Types.ChallengeResponse {
        return List.find<Types.ChallengeResponse>(generatedResponses, func(responseEntry: Types.ChallengeResponse) : Bool { responseEntry.challengeId == challengeId } ); 
    };

    private func getGeneratedResponses() : [Types.ChallengeResponse] {
        return List.toArray<Types.ChallengeResponse>(generatedResponses);
    };

    private func removeGeneratedResponse(challengeId : Text) : Bool {
        generatedResponses := List.filter(generatedResponses, func(responseEntry: Types.ChallengeResponse) : Bool { responseEntry.challengeId != challengeId });
        return true;
    };

    // Record of submitted responses
    stable var submittedResponses : List.List<Types.ChallengeResponseSubmission> = List.nil<Types.ChallengeResponseSubmission>();
    
    private func putSubmittedResponse(responseEntry : Types.ChallengeResponseSubmission) : Bool {
        let putResult = List.push<Types.ChallengeResponseSubmission>(responseEntry, submittedResponses);
        return true;
    };

    private func getSubmittedResponse(submissionId : Text) : ?Types.ChallengeResponseSubmission {
        return List.find<Types.ChallengeResponseSubmission>(submittedResponses, func(responseEntry: Types.ChallengeResponseSubmission) : Bool { responseEntry.submissionId == submissionId } ); 
    };

    private func getSubmittedResponses() : [Types.ChallengeResponseSubmission] {
        return List.toArray<Types.ChallengeResponseSubmission>(submittedResponses);
    };

    private func removeSubmittedResponse(submissionId : Text) : Bool {
        submittedResponses := List.filter(submittedResponses, func(responseEntry: Types.ChallengeResponseSubmission) : Bool { responseEntry.submissionId != submissionId });
        return true;
    };

    // For debug purposes, save latest story that was generated by this canister
    // private var latestStoryOutputRecordResult : Types.StoryOutputRecordResult = #Ok({
    //     storyID = "";
    //     storyPrompt = "";
    //     story = "";
    // });

    // Round-robin load balancer for LLM canisters to call
    private var roundRobinIndex : Nat = 0;
    private var roundRobinUseAll : Bool = true;
    private var roundRobinLLMs : Nat = 0; // Only used when roundRobinUseAll is false

    // Generate the array of values from 0 to 100000 in steps of 11
    let seedValues: [Nat64] = Array.tabulate(100000, func(index: Nat) : Nat64 {
        return Nat64.fromNat(index * 11);
    });

    // Variable to track the current index
    var currentSeedIndex: Nat = 0;

    // Function to get the next rng_seed
    private func getNextRngSeed(): Nat64 {
        let seed = seedValues[currentSeedIndex];
        // Update the index to the next value, cycling back to 0
        currentSeedIndex := (currentSeedIndex + 1) % seedValues.size();
        return seed;
    };

    // The llmCanisterIDs this ctrlb_canister can call
    private var llmCanisterIDs : Buffer.Buffer<Text> = Buffer.fromArray<Text>([]);

    // whitelisted principals (admins)
    private var whitelistedPrincipals : Buffer.Buffer<Principal> = Buffer.fromArray<Principal>([]);

    // -------------------------------------------------------------------------------
    // The C++ LLM canisters that can be called

    private var llmCanisters : Buffer.Buffer<Types.LLMCanister> = Buffer.fromArray([]);

    // Resets llmCanisterIDs, and then adds the argument as the first llmCanisterId
    public shared (msg) func set_llm_canister_id(llmCanisterIdRecord : Types.CanisterIDRecord) : async Types.StatusCodeRecordResult {
        if (Principal.isAnonymous(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        if (not Principal.isController(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        llmCanisterIDs.clear();
        _add_llm_canister_id(llmCanisterIdRecord);
    };

    // Adds another llmCanisterIDs
    public shared (msg) func add_llm_canister_id(llmCanisterIdRecord : Types.CanisterIDRecord) : async Types.StatusCodeRecordResult {
        if (Principal.isAnonymous(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        if (not Principal.isController(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        _add_llm_canister_id(llmCanisterIdRecord);
    };

    // Resets llmCanisterIDs, and then adds the argument as the first llmCanisterId
    private func _add_llm_canister_id(llmCanisterIdRecord : Types.CanisterIDRecord) : Types.StatusCodeRecordResult {
        let llmCanister = actor (llmCanisterIdRecord.canister_id) : Types.LLMCanister;
        D.print("Inside function _add_llm_canister_id. Adding llm: " # Principal.toText(Principal.fromActor(llmCanister)));
        llmCanisters.add(llmCanister);

        // Print content of the llmCanisters Buffer:
        D.print("Content of llmCanisters after addition: ");
        Buffer.iterate(
            llmCanisters,
            func(canister : Types.LLMCanister) : () {
                D.print("Canister ID: " # Principal.toText(Principal.fromActor(canister)));
            },
        );
        return #Ok({ status_code = 200 });
    };

    public shared query (msg) func WhitelistedPrincipals() : async [Principal] {
        if (Principal.isAnonymous(msg.caller)) {
            return [];
        };
        assert Principal.isController(msg.caller);
        Buffer.toArray(whitelistedPrincipals);
    };

    public shared query (msg) func whoami() : async Principal {
        return msg.caller;
    };

    // Function to verify that canister is up & running
    public shared query func health() : async Types.StatusCodeRecordResult {
        return #Ok({ status_code = 200 });
    };

    // Function to verify that canister is ready for inference
    public shared (msg) func ready() : async Types.StatusCodeRecordResult {
        if (Principal.isAnonymous(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        for (llmCanister in llmCanisters.vals()) {
            try {
                let statusCodeRecordResult : Types.StatusCodeRecordResult = await llmCanister.ready();
                switch (statusCodeRecordResult) {
                    case (#Err(_)) { return statusCodeRecordResult };
                    case (_) {
                        // If it's not an error, do nothing and continue the loop
                    };
                };
            } catch (_) {
                // Handle errors, such as llm canister not responding
                return #Err(#Other("Failed to call ready endpoint of llm canister = " # Principal.toText(Principal.fromActor(llmCanister))));
            };
        };
        return #Ok({ status_code = 200 });
    };

    // Admin function to verify that caller is a controller of this canister
    public shared query (msg) func amiController() : async Types.StatusCodeRecordResult {
        if (Principal.isAnonymous(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        if (not Principal.isController(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        return #Ok({ status_code = 200 });
    };

    // Admin function to whitelist a principal for updating the NFTs by their token_id
    // (-) The bioniq launch canister must be whitelisted.
    public shared (msg) func whitelistPrincipal(principal : Principal) : async Types.StatusCodeRecordResult {
        if (Principal.isAnonymous(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        if (not Principal.isController(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        whitelistedPrincipals.add(principal);
        return #Ok({ status_code = 200 });
    };

    // Admin function to verify that caller is whitelisted in this canister
    public shared query (msg) func amiWhitelisted() : async Types.StatusCodeRecordResult {
        if (Principal.isAnonymous(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        if (not isWhitelisted(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        return #Ok({ status_code = 200 });
    };

    // Admin function to verify that ctrlb_canister is whitelisted in the llm canister
    public shared (msg) func isWhitelistLogicOk() : async Types.StatusCodeRecordResult {
        if (Principal.isAnonymous(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        if (not Principal.isController(msg.caller)) {
            return #Err(#StatusCode(401));
        };

        // Call all the llm canisters to verify that ctrlb_canister is whitelisted
        for (llmCanister in llmCanisters.vals()) {
            try {
                let statusCodeRecordResult : Types.StatusCodeRecordResult = await llmCanister.nft_ami_whitelisted();
                switch (statusCodeRecordResult) {
                    case (#Err(_)) { return statusCodeRecordResult };
                    case (_) {
                        // If it's not an error, do nothing and continue the loop
                    };
                };
            } catch (_) {
                // Handle errors, such as llm canister not responding
                return #Err(#Other("Failed to retrieve whitelist info for llm canister = " # Principal.toText(Principal.fromActor(llmCanister))));
            };
        };
        return #Ok({ status_code = 200 });
    };

    // Helper function to check if a principal is whitelisted
    private func isWhitelisted(principal : Principal) : Bool {
        return Principal.isController(principal) or Buffer.contains<Principal>(whitelistedPrincipals, principal, Principal.equal);
    };

    // Admin function to set roundRobinLLMs
    public shared (msg) func setRoundRobinLLMs(_roundRobinLLMs : Nat) : async Types.StatusCodeRecordResult {
        if (Principal.isAnonymous(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        if (not Principal.isController(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        roundRobinUseAll := false;
        roundRobinLLMs := _roundRobinLLMs;
        roundRobinIndex := 0;

        return #Ok({ status_code = 200 });
    };

// Settings

    public shared (msg) func updateAgentSettings(settingsInput : Types.MainerAgentSettingsInput) : async Types.StatusCodeRecordResult {
        if (Principal.isAnonymous(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        if (not Principal.isController(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        let settingsEntry : Types.MainerAgentSettings = {
            cyclesBurnRate : Types.CyclesBurnRate = settingsInput.cyclesBurnRate;
            creationTimestamp : Nat64 = Nat64.fromNat(Int.abs(Time.now()));
            createdBy : Principal = msg.caller;
        };
        let putResult = putAgentSettings(settingsEntry);
        if (not putResult) {
            return #Err(#StatusCode(500));
        };
        return #Ok({ status_code = 200 });
    };

// Respond to challenges

    private func getChallengeFromGameStateCanister() : async Types.ChallengeResult {
        let result : Types.ChallengeResult = await gameStateCanisterActor.getRandomOpenChallenge();
        return result;
    };

    private func submitResponseToGameStateCanister(response : Types.ChallengeResponse, submittedBy : Principal) : async Types.ChallengeResponseSubmissionResult {
        let responseInput : Types.ChallengeResponseSubmissionInput = {
            challengeId : Text = response.challengeId;
            submittedBy : Principal = submittedBy;
            response : Text = response.generatedResponseText;
        };
        let result : Types.ChallengeResponseSubmissionResult = await gameStateCanisterActor.submitChallengeResponse(responseInput);
        return result;
    };

    private func processRespondingToChallenge(challenge : Types.Challenge) : async () {
        let scoringPrompt : Text = ""; // TODO: put standard prompt

        let rng_seed = getNextRngSeed();
        let startPrompt : Types.Prompt = {
            prompt = scoringPrompt;
            steps = 60;
            temperature = 0.1;
            topp = 0.9;
            rng_seed = rng_seed;
        };

        let llmCanister = _getRoundRobinCanister();

        let respondingResult : Types.ChallengeResponseResult = await respondToChallengeDoIt_(llmCanister, startPrompt, challenge.challengeId);
        switch (respondingResult) {
            case (#Err(error)) {
                // TODO: error handling
            };
            case (#Ok(respondingOutput : Types.ChallengeResponse)) {                
                // Store response
                let storeResult : Bool = putGeneratedResponse(respondingOutput);

                switch (storeResult) {
                    case (false) {
                        // TODO: error handling
                    };
                    case (true) {
                        // Submit response to Game State canister
                        let submittedBy : Principal = Principal.fromActor(this);
                        let submitResult : Types.ChallengeResponseSubmissionResult = await submitResponseToGameStateCanister(respondingOutput, submittedBy);
                        switch (submitResult) {
                            case (#Err(error)) {
                                // TODO: error handling
                            };
                            case (#Ok(submissionReturnValue : Types.ChallengeResponseSubmissionReturn)) {
                                // Successfully submitted to Game State
                                let submittedResponseEntry : Types.ChallengeResponseSubmission = {
                                    challengeId : Text = challenge.challengeId;
                                    submittedBy : Principal = submittedBy;
                                    response : Text = respondingOutput.generatedResponseText;
                                    submissionId : Text = submissionReturnValue.submissionId;
                                    submittedTimestamp : Nat64 = submissionReturnValue.submittedTimestamp;
                                    status: Types.ChallengeResponseSubmissionStatus = submissionReturnValue.status;
                                };
                                let putResult = putSubmittedResponse(submittedResponseEntry);
                                switch (putResult) {
                                    case (false) {
                                        // TODO: error handling
                                    };
                                    case (true) {};
                                };
                            };
                        }; 
                    };
                };               
            };
        };
    };

    private func respondToNextChallenge() : async () {
        // TODO: incorporate cycles burn rate setting
        
        // Get the next challenge to respond to
        let challengeResult : Types.ChallengeResult = await getChallengeFromGameStateCanister();
        switch (challengeResult) {
            case (#Err(error)) {
                // TODO: error handling
            };
            case (#Ok(nextChallenge : Types.Challenge)) {
                // Process the challenge
                // Sanity checks
                if (nextChallenge.challengeId == "" or nextChallenge.challengePrompt == "") {
                    return;
                };
                switch (nextChallenge.status) {
                    case (#Open) {
                        // continue
                    };
                    case (_) { return; }
                };
                switch (nextChallenge.closedTimestamp) {
                    case (null) {
                        // continue
                    };
                    case (_) { return; }
                };

                // Get response generated for challenge and submit it
                ignore processRespondingToChallenge(nextChallenge);
                return;
            };
        };
    };

    /* public shared query (msg) func StoryGet(storyInputRecord: Types.StoryInputRecord) : async Types.StoryOutputRecordResult {
        if (Principal.isAnonymous(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        if (not isWhitelisted(msg.caller)) {
            return #Err(#StatusCode(401));
        };

        let storyID : Types.StoryID = storyInputRecord.storyID; 
        let storyPrompt : Text = storyInputRecord.storyPrompt;

        var storyOutputRecordResult : Types.StoryOutputRecordResult = #Ok({
            storyID = storyID;
            storyPrompt = storyPrompt;
            story = "";
            status = "unknown";
            llmCanisterID = "";
        });

        let maybeLatestStoryOutputRecordResult = latestStoryOutputRecordResult.get(storyID);
        switch (maybeLatestStoryOutputRecordResult) {
            case (null) {
                return #Err(
                    #Other(
                        "storyID " # storyID # " does not yet exist."
                    )
                );
            };
            case (?v) {
                storyOutputRecordResult := v;
                return storyOutputRecordResult;
            };
        };
    }; */

    public shared query (msg) func getRoundRobinCanister() : async Types.CanisterIDRecordResult {
        if (Principal.isAnonymous(msg.caller)) {
            return #Err(#StatusCode(401));
        };
        let canisterIDRecord : Types.CanisterIDRecord = {
            canister_id = Principal.toText(Principal.fromActor(_getRoundRobinCanister()));
        };
        return #Ok(canisterIDRecord);
    };

    private func _getRoundRobinCanister() : Types.LLMCanister {
        D.print("_getRoundRobinCanister: using roundRobinIndex " # Nat.toText(roundRobinIndex));
        let canister = llmCanisters.get(roundRobinIndex);
        roundRobinIndex += 1;

        var roundRobinIndexTurn = llmCanisters.size();
        if (roundRobinUseAll == false) {
            roundRobinIndexTurn := Utils.minNat(roundRobinIndexTurn, roundRobinLLMs);
        };

        if (roundRobinIndex >= roundRobinIndexTurn) {
            roundRobinIndex := 0;
        };

        return canister;
    };

    private func respondToChallengeDoIt_(llmCanister: Types.LLMCanister, startPrompt : Types.Prompt, challengeId : Text) : async Types.ChallengeResponseResult {
        D.print("Inside function respondToChallengeDoIt_. llmCanister = " # Principal.toText(Principal.fromActor(llmCanister)));

        // The llama2_c canisters refers to each process with a token_id
        let llmInput: Types.NFT_llama2_c = {
            token_id = challengeId;
        };

        // Start a new generation for this challenge
        var generatedText : Text = "";
        var generation_num_tokens : Nat64 = 0;
        var num_update_calls : Nat64 = 0;
        try {
            D.print("---ctrlb_canister---");
            D.print("calling nft_story_start_mo with : "); // TODO: different call than nft_story_start_mo
            D.print("llmInput       : " # debug_show (llmInput));
            D.print("startPrompt : " # debug_show (startPrompt));
            num_update_calls += 1;
            let inferenceRecordResult : Types.InferenceRecordResult = await llmCanister.nft_story_start_mo(llmInput, startPrompt);
            D.print("---ctrlb_canister---");
            D.print("returned from nft_story_start_mo with : ");
            D.print("inferenceRecordResult: " # debug_show (inferenceRecordResult));

            switch (inferenceRecordResult) {
                case (#Err(error)) {
                    return #Err(error);
                };
                case (#Ok(inferenceRecord)) {
                    // the generated tokens
                    let inference : Text = inferenceRecord.inference;
                    let inference_num_tokens : Nat64 = inferenceRecord.num_tokens;
                    generatedText := inference;
                    generation_num_tokens += inference_num_tokens;
                    D.print("generatedText" # debug_show (generatedText));
                    D.print("generation_num_tokens" # debug_show (generation_num_tokens));
                };
            };
        } catch (error : Error) {
            // Handle errors, such as llm canister not responding
            D.print("---ctrlb_canister---");
            D.print("catch error when nft_story_start : ");
            D.print("error: " # Error.message(error));
            return #Err(
                #Other(
                    "Failed call to nft_story_start_mo of " # Principal.toText(Principal.fromActor(llmCanister)) #
                    " with error: " # Error.message(error)
                )
            );
        };

        // Continue the scoring, until it returns an empty string
        // Avoid endless loop by limiting the number of iterations
        let continuePrompt : Types.Prompt = {
            prompt : Text = "";
            steps : Nat64 = startPrompt.steps;
            temperature : Float = startPrompt.temperature;
            topp : Float = startPrompt.topp;
            rng_seed : Nat64 = startPrompt.rng_seed;
        };
        var continueLoopCount : Nat = 0;
        label continueLoop while (continueLoopCount < 5) { // TODO: determine number of allowed loops
            try {
                D.print("---ctrlb_canister---");
                D.print("calling nft_story_continue_mo with : ");
                D.print("llmInput         : " # debug_show (llmInput));
                D.print("continuePrompt : " # debug_show (continuePrompt));
                num_update_calls += 1;
                let inferenceRecordResult : Types.InferenceRecordResult = await llmCanister.nft_story_continue_mo(llmInput, continuePrompt);
                D.print("---ctrlb_canister---");
                D.print("returned nft_story_continue_mo with : ");
                D.print("inferenceRecordResult: " # debug_show (inferenceRecordResult));

                switch (inferenceRecordResult) {
                    case (#Err(error)) {
                        return #Err(error);
                    };
                    case (#Ok(inferenceRecord)) {
                        // the generated tokens
                        let inference : Text = inferenceRecord.inference;
                        let inference_num_tokens : Nat64 = inferenceRecord.num_tokens;
                        // D.print("inference :" # debug_show (inference));
                        // D.print("inference_num_tokens :" # Nat64.toText(inference_num_tokens));

                        generatedText := generatedText # inference;
                        generation_num_tokens += inference_num_tokens;
                        // D.print("generatedText" # debug_show (generatedText));
                        // D.print("generation_num_tokens" # debug_show (generation_num_tokens));

                        if (inference_num_tokens < continuePrompt.steps) {
                            break continueLoop; // Exit the loop because the LLM is done. It will only predict "" from now on.
                        };
                    };
                };
            } catch (error : Error) {
                // Handle errors, such as llm_0 not responding
                D.print("---ctrlb_canister---");
                D.print("catch error when nft_story_start : ");
                D.print("error: " # Error.message(error));
                return #Err(
                    #Other(
                        "Failed call to nft_story_start of " # Principal.toText(Principal.fromActor(llmCanister)) #
                        " with error: " # Error.message(error)
                    )
                );
            };
            continueLoopCount += 1;
        };

        // Delete the process in the LLM
        try {
            D.print("---ctrlb_canister---");
            D.print("calling nft_story_delete with : "); // TODO: different call
            D.print("llmInput       : " # debug_show (llmInput));
            let statusCodeRecordResult : Types.StatusCodeRecordResult = await llmCanister.nft_story_delete(llmInput);
            D.print("---ctrlb_canister---");
            D.print("returned from nft_story_delete with : ");
            D.print("statusCodeRecordResult: " # debug_show (statusCodeRecordResult));

        } catch (error : Error) {
            // Handle errors, such as llm canister not responding
            D.print("---ctrlb_canister---");
            D.print("catch error when nft_story_start : ");
            D.print("error: " # Error.message(error));
            return #Err(
                #Other(
                    "Failed call to nft_story_start_mo of " # Principal.toText(Principal.fromActor(llmCanister)) #
                    " with error: " # Error.message(error)
                )
            );
        };

        // Return the generated response
        let responseOutput : Types.ChallengeResponse = {
            challengeId : Text = challengeId;
            generationPrompt : Text = startPrompt.prompt;     
            generatedTimestamp : Nat64 = Nat64.fromNat(Int.abs(Time.now()));
            generatedByLlmId : Text = Principal.toText(Principal.fromActor(llmCanister));
            generatedResponseText : Text = generatedText;
        };
        return #Ok(responseOutput);
    };
};
